---
layout: post
title: Writing A Wrapper Tool For A JAR
date: '2013-04-15T00:14:00.003-04:00'
author: Brett Koenig
tags:
- Java
- jRuby
- Warbler
- JAR
modified_time: '2013-04-15T00:19:29.808-04:00'
---

I am currently working on a project where I had to write a wrapper for a Java JAR. &nbsp;Since I was trying to compare the results of two different automated test generation tools, I needed them to behave in a similar fashion. &nbsp;<a href="http://www.evosuite.org/">EvoSuite</a>, despite what the documentation claims, creates tests for each class in a JAR using the specified maximum time as the maximum time for each class. &nbsp;On the other hand&nbsp;<a href="https://code.google.com/p/randoop/">Randoop</a>&nbsp;creates tests for the entire JAR stopping when the maximum time is reached. &nbsp;I needed Randoop to behave like EvoSuite and use the maximum amount of time per class. &nbsp;In order to achieve this goal, I used jRuby to write a wrapper around Randoop for the specific call that I would be making to it.<br /><br /><a name='more'></a>The first thing you need to do is set up your project in the proper way.<br /><br />/bin<br />&nbsp; --randoop (this is the file that gets user input)<br />/lib<br />&nbsp; --all the classes that the bin file uses<br /><br />This is my bin/randoop file:<br /><br /><br /><pre class="brush: ruby;" name="code">#!/home/brett/.rvm/rubies/jruby-1.7.3/bin/jruby<br /><br />$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)<br />require 'Randoop'<br />require 'trollop'<br /><br />p = Trollop::Parser.new do<br /> version "Randoop 1.3.3"<br /> banner &lt;&lt;-EOS<br /><br />Randoop will automatically generate a jUnit test suite for a given jar.<br />It uses a random algorithm with a unique heuristic to prune the inputs<br />so that coverage is improved over completely random test input generators.<br /><br /><br />  randoop &lt;jarfile&gt; [options]<br /><br />where [options] are:<br />EOS<br /><br /> opt :classlist, "Location of a file that contains the list of Java classes", :short =&gt; 'c', :type =&gt; :string, :default =&gt; nil<br /> opt :maxtime, "Maximum amount of time each class is given to random generate tests", :short =&gt; 'm', :type =&gt; :integer, :default =&gt; 60<br /> opt :nocleanup, "Don't clean up temporary files", :type =&gt; :flag<br /> opt :jdk_jar, "Path to Oracle's JDK 'jar' executable", :type =&gt; :string<br /> opt :output_dir, "Specify the output directory", :type =&gt; :string<br />end<br /><br />opts = Trollop::with_standard_exception_handling p do<br /> raise Trollop::HelpNeeded if ARGV.empty?<br /> p.parse ARGV<br />end<br /><br />#additional errros<br />Trollop::with_standard_exception_handling p do<br /> raise Trollop::CommandlineError, "File '#{ARGV[0]}' does not exist" unless File.exist?(ARGV[0])<br /> raise Trollop::CommandlineError, "Directory '#{opts[:output_dir]}' does not exist" unless !opts[:output_dir] || Dir.exist?(opts[:output_dir])<br />end<br /><br />randoop = Randoop::Main.new(ARGV[0], opts)<br />randoop.start<br />randoop.cleanup unless opts[:nocleanup]<br /></pre><br />Side note: I really recommend&nbsp;<a href="http://trollop.rubyforge.org/">trollop</a>&nbsp;as an easy to use tool to specify usage and get command line parameters. &nbsp;It makes things easy.<br /><br />After you have everything created and ready to go, you can use the warbler gem to create an executable jar out of your project. &nbsp;In the project root just type<br /><blockquote class="tr_bq">$ warble jar</blockquote>and the tool should figure everything out for you.<br /><br />So all of that was fairly easy so far. &nbsp;I ran into trouble when I wanted to package the jar that I was wrapping and call it from inside jRuby. &nbsp;In order to run the command on the internal Randoop JAR, I had to first extract it and then run the command. &nbsp;The only way I could figure out how to do it was to use Java. &nbsp;This is the jRuby code I wrote to accomplish extracting the original Randoop JAR.<br /><br /><br /><pre class="brush: ruby;" name="code">BUFFER = 2048<br />def extract_randoop<br />  require 'java'<br />  randoop_path = __FILE__.gsub('jar:file:', '').split('!')[0]<br />  zis = java.util.zip.ZipInputStream.new(java.io.BufferedInputStream.new(java.io.FileInputStream.new(randoop_path)))<br />  while (entry = zis.getNextEntry()) != nil<br />    if entry.to_s =~ /^.+randoop[\.0-9]*\.jar/<br />      File.open('randoop.jar', 'w'){} unless File.exist?('randoop.jar')<br />      dest = java.io.BufferedOutputStream.new(java.io.FileOutputStream.new('randoop.jar'), BUFFER)<br />      data = Java::byte[BUFFER].new<br />      while (count = zis.read(data, 0, BUFFER)) != -1<br />        dest.write(data,0,count)<br />      end<br />      dest.flush()<br />      dest.close()<br />    end<br />  end<br />  zis.close()<br />  return File.join(Dir.pwd, 'randoop.jar')<br />end<br /></pre><br />From there everything should work. &nbsp;I'm sure this isn't a common problem that people have but it took me a while to figure out why my program wasn't working after I created the JAR because it worked perfectly when I ran it as a jRuby script. &nbsp;Hopefully this helps someone else out there.<br /><br />Peace!